---
title: "Support Vector Machines"
author: "Seif Kungulio"
date: "04/14/2025"
output:
  rmdformats::readthedown
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Install necessary packages if not installed
if (!requireNamespace("e1071", quietly = TRUE)) {
  install.packages("e1071")
}
if (!requireNamespace("caret", quietly = TRUE)) {
  install.packages("caret")
}

# Load necessary libraries
library(e1071)
library(caret)
```
<hr style="height:5px; border:none; color:#006000; background-color:#006000;" />

# **Forecast Bike Rental Demand**
<hr style="height:2px; border:none; color:#333; background-color:#333;" />

You are working as a data scientist for the government in the city of Washington, D.C. Currently, Washington, D.C has a bike sharing system. People could rent a bike from one location and return it to a different place. You are given a historical usage pattern with weather data contained in the Excel workbook bike.csv. You are asked to forecast bike rental demand in the capital bike share program.

**Data Source:** from Kaggle at https://www.kaggle.com/c/bike-sharing-demand


## **Data Dictionary**
This dataset contains the following columns:

| **Variable** | **Description** | **Data Type** | **Rules/Constraints** |
|:-------------|:----------------|:--------------|:----------------------|
| **`datetime`** | Date and time of the observation | Timestamp | Must be unique and in ISO 8601 format (YYYY-MM-DD HH:MM:SS). |
| **`season`** | Season (1: Winter, 2: Spring, 3: Summer, 4: Fall) | Categorical | Must be an integer between 1 and 4. |
| **`holiday`** | Whether the day is a holiday (0: No, 1: Yes) | Binary | Must be 0 or 1. |
| **`workingday`** | Whether the day is a working day (0: No, 1: Yes) | Binary | Must be 0 or 1. |
| **`weather`** | Weather condition (1 to 4, where 1: Clear, 4: Extreme) | Categorical | Must be an integer between 1 and 4. |
| **`temp`** | Normalized temperature in Celsius | Continuous | Must be between 0 and 41. |
| **`atemp`** | Normalized "feels like" temperature in Celsius | Continuous | Must be between 0 and 45.455. |
| **`humidity`** | Relative humidity (%) | Continuous | Must be between 0 and 100. |
| **`windspeed`** | Wind speed in km/h | Continuous | Must be non-negative, and maximum value is approximately 56.9979. |
| **`casual`** | Number of casual (non-registered) users | Integer | Must be non-negative, with a maximum of 367. |
| **`registered`** | Number of registered users | Integer | Must be non-negative, with a maximum of 886. |
| **`count`** | Total number of bike rentals | Integer | Must equal casual + registered, and be non-negative. |

<br>

## **Question 1**
Load the dataset bike.csv into memory. Convert holiday to a factor using factor() function. Then split the data into training set containing 2/3 of the original data (test set containing remaining 1/3 of the original data).

Read the dataset into memory
```{r}
Bike.df <- read.csv("data/Bike.csv")
```

Display the dimensions of the data frame (number of rows and columns)
```{r}
dim(Bike.df)
```

Display the column names of the data frame
```{r}
colnames(Bike.df)
```

Display the first six rows of the data frame to understand its structure
```{r}
head(Bike.df)
```

Convert categorical variables to factors
```{r}
# 
Bike.df$season = factor(Bike.df$season,
                        levels = c(1, 2, 3, 4),
                        labels = c("Spring", "Summer", "Fall", "Winter")
)

Bike.df$holiday <- factor(Bike.df$holiday, 
                          levels = c(0,1), 
                          labels = c("Non-Holiday", "Holiday")
)

Bike.df$workingday <- factor(Bike.df$workingday,
                             levels = c(0,1), 
                             labels = c("Non-Workingday", "Workingday")
)

Bike.df$weather <- factor(Bike.df$weather,
                          levels = c(1, 2, 3, 4),
                          labels = c("Clear", "Misty_cloudy",
                                     "Light_snow", "Heavy_rain")
)
```

Split the data into a training set (2/3) and test set (1/3)
```{r}
# Set seed for reproducibility
set.seed(1)

# Create train index that will contain 2/3 of the dataset
trainIdx = sample(1:nrow(Bike.df), size = 2/3 * nrow(Bike.df))

# Create a training dataset out of "Bike.df"
trainData = Bike.df[trainIdx, ]

# Create a testing dataset from the remaining dataset of "Bike.df"
testData  <- Bike.df[-trainIdx, ]
```

Check the dimension of training dataset and testing dataset
```{r}
# Check the dimension of training dataset
dim(trainData)

# Check the dimension of testing dataset
dim(testData)
```

<br>

## **Question 2**
**Build a support vector machine model.**

### **Section A**
The response is `holiday` and the predictors are: `season`, `workingday`, `casual`, and `registered`. Please use `svm()` function with radial kernel and gamma = 10 and cost = 100.
```{r}
svm.model <- svm(holiday ~ season + workingday + casual + registered,
                 data = trainData,
                 kernel = "radial",
                 gamma = 10,
                 cost = 100)
summary(svm.model)
```
The SVM model uses a radial kernel for a binary classification task (Holiday vs. Non-Holiday), with a gamma of 10 and cost of 100. These parameters increase model complexity, potentially improving fit but also raising the risk of overfitting.

The model relies on 633 support vectors (428 from one class, 205 from the other), indicating that the data may not be easily separable. This could also reflect some class imbalance.  

<hr>

### **Section B**
Perform a grid search to find the best model with potential cost: 1, 10, 50, 100 and potential gamma: 1, 3, and 5 and using radial kernel and training dataset.
```{r}
tuned.results <- tune(svm, holiday ~ season + workingday + casual + registered, 
                     data = trainData, kernel = "radial", 
                     ranges = list(cost = c(1, 10, 50, 100), 
                                   gamma = c(1, 3, 5)
                     ))
summary(tuned.results)
```
Models with gamma = 1 consistently outperformed those with higher gamma values, regardless of the cost setting. Increasing the cost from 1 to 100 led to steadily lower error rates, with the best performance achieved at cost = 100 and gamma = 1. In contrast, higher gamma values caused the model to overfit, resulting in poorer generalization.

Despite a slightly higher error variance, the best model remains stable and reliable. It strikes a solid balance between accuracy and generalization, making it the ideal configuration. It’s recommended to train the final SVM using these parameters and validate it on a test set to ensure robust performance.  

<hr>

### **Section C**
Print out the model results. What’s the best model parameters?
```{r}
best_tuned.model <- tuned.results$best.model
summary(best_tuned.model)
```
The SVM model was designed to predict holidays using features like season, workingday, casual, and registered, employing a radial basis function (RBF) kernel to handle non-linear patterns. Through grid search tuning over various cost and gamma values, the optimal parameters were found to be cost = 100 and gamma = 1, resulting in the lowest cross-validation error.

The final model uses 645 support vectors (440 for Non-Holiday, 205 for Holiday), indicating a complex decision boundary and slight class imbalance. This imbalance may affect model predictions, favoring the majority class.  

<hr>

### **Section D**
Forecast `holiday` using the test dataset and the best model found in c).
```{r}
predictions <- predict(best_tuned.model, newdata = testData)
summary(predictions)
```
This summary suggests a strong imbalance in predicted outcomes, with most predictions being “Non-Holiday”.  

<hr>

### **Section E**
Get the true observations of `holiday` in the test dataset.
```{r}
#observations <- testData$holiday
actuals <- Bike.df[-trainIdx, "holiday"]
summary(actuals)
```
The summary suggests that most records (3532 out of 3629) are from “Non-Holiday” periods, while only a small subset of records (97) correspond to Holidays. This imbalance in the data might influence modeling results.  

<hr>

### **Section F**
Compute the test error by constructing the confusion matrix. Is it a good model?
```{r}
conf.matrix <- confusionMatrix(predictions, actuals)
print(conf.matrix)
```
**Test Error = 1 – Accuracy = 1 – 0.9746 = 0.0254**

The model demonstrates high overall accuracy (97.46%) and excellent sensitivity for identifying Non-Holidays, but it performs poorly in detecting Holidays due to significant class imbalance. With low specificity (7.2%), a poor Kappa score (0.1281), and low balanced accuracy (53.58%), the model is heavily biased toward the majority class. Despite appearing effective at first glance, it fails to reliably identify the minority class (Holidays), making it unsuitable if accurate Holiday prediction is important.

